// Code generated by protoc-gen-go. DO NOT EDIT.
// source: indexer_manager.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// IndexerInfo provides info about a state indexer.
type IndexerInfo struct {
	// indexer_id is the indexer's ID.
	IndexerId string `protobuf:"bytes,1,opt,name=indexer_id,json=indexerId,proto3" json:"indexer_id,omitempty"`
	// actual_version is the indexer's current version.
	ActualVersion uint32 `protobuf:"varint,2,opt,name=actual_version,json=actualVersion,proto3" json:"actual_version,omitempty"`
	// desired_version is the version to which the indexer will be reindexed.
	DesiredVersion       uint32   `protobuf:"varint,3,opt,name=desired_version,json=desiredVersion,proto3" json:"desired_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexerInfo) Reset()         { *m = IndexerInfo{} }
func (m *IndexerInfo) String() string { return proto.CompactTextString(m) }
func (*IndexerInfo) ProtoMessage()    {}
func (*IndexerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a75d319d3afccd2, []int{0}
}

func (m *IndexerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IndexerInfo.Unmarshal(m, b)
}
func (m *IndexerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IndexerInfo.Marshal(b, m, deterministic)
}
func (m *IndexerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerInfo.Merge(m, src)
}
func (m *IndexerInfo) XXX_Size() int {
	return xxx_messageInfo_IndexerInfo.Size(m)
}
func (m *IndexerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerInfo proto.InternalMessageInfo

func (m *IndexerInfo) GetIndexerId() string {
	if m != nil {
		return m.IndexerId
	}
	return ""
}

func (m *IndexerInfo) GetActualVersion() uint32 {
	if m != nil {
		return m.ActualVersion
	}
	return 0
}

func (m *IndexerInfo) GetDesiredVersion() uint32 {
	if m != nil {
		return m.DesiredVersion
	}
	return 0
}

type GetIndexersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetIndexersRequest) Reset()         { *m = GetIndexersRequest{} }
func (m *GetIndexersRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexersRequest) ProtoMessage()    {}
func (*GetIndexersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a75d319d3afccd2, []int{1}
}

func (m *GetIndexersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetIndexersRequest.Unmarshal(m, b)
}
func (m *GetIndexersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetIndexersRequest.Marshal(b, m, deterministic)
}
func (m *GetIndexersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexersRequest.Merge(m, src)
}
func (m *GetIndexersRequest) XXX_Size() int {
	return xxx_messageInfo_GetIndexersRequest.Size(m)
}
func (m *GetIndexersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexersRequest proto.InternalMessageInfo

type GetIndexersResponse struct {
	// indexers_by_id contains all tracked indexers, keyed by their ID.
	IndexersById         map[string]*IndexerInfo `protobuf:"bytes,1,rep,name=indexers_by_id,json=indexersById,proto3" json:"indexers_by_id,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GetIndexersResponse) Reset()         { *m = GetIndexersResponse{} }
func (m *GetIndexersResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexersResponse) ProtoMessage()    {}
func (*GetIndexersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a75d319d3afccd2, []int{2}
}

func (m *GetIndexersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetIndexersResponse.Unmarshal(m, b)
}
func (m *GetIndexersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetIndexersResponse.Marshal(b, m, deterministic)
}
func (m *GetIndexersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexersResponse.Merge(m, src)
}
func (m *GetIndexersResponse) XXX_Size() int {
	return xxx_messageInfo_GetIndexersResponse.Size(m)
}
func (m *GetIndexersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexersResponse proto.InternalMessageInfo

func (m *GetIndexersResponse) GetIndexersById() map[string]*IndexerInfo {
	if m != nil {
		return m.IndexersById
	}
	return nil
}

type StartReindexRequest struct {
	// indexer_id is the ID of the indexer to reindex.
	// If indexer_id is empty, will reindex all necessary indexers.
	IndexerId string `protobuf:"bytes,1,opt,name=indexer_id,json=indexerId,proto3" json:"indexer_id,omitempty"`
	// force the reindex to occur.
	// By default, start reindex will fail if automatic reindexing is enabled.
	// Set force=true to overrule this default.
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartReindexRequest) Reset()         { *m = StartReindexRequest{} }
func (m *StartReindexRequest) String() string { return proto.CompactTextString(m) }
func (*StartReindexRequest) ProtoMessage()    {}
func (*StartReindexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a75d319d3afccd2, []int{3}
}

func (m *StartReindexRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReindexRequest.Unmarshal(m, b)
}
func (m *StartReindexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReindexRequest.Marshal(b, m, deterministic)
}
func (m *StartReindexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReindexRequest.Merge(m, src)
}
func (m *StartReindexRequest) XXX_Size() int {
	return xxx_messageInfo_StartReindexRequest.Size(m)
}
func (m *StartReindexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReindexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartReindexRequest proto.InternalMessageInfo

func (m *StartReindexRequest) GetIndexerId() string {
	if m != nil {
		return m.IndexerId
	}
	return ""
}

func (m *StartReindexRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type StartReindexResponse struct {
	// update contains a human-readable update on reindex progress
	Update               string   `protobuf:"bytes,1,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartReindexResponse) Reset()         { *m = StartReindexResponse{} }
func (m *StartReindexResponse) String() string { return proto.CompactTextString(m) }
func (*StartReindexResponse) ProtoMessage()    {}
func (*StartReindexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a75d319d3afccd2, []int{4}
}

func (m *StartReindexResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReindexResponse.Unmarshal(m, b)
}
func (m *StartReindexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReindexResponse.Marshal(b, m, deterministic)
}
func (m *StartReindexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReindexResponse.Merge(m, src)
}
func (m *StartReindexResponse) XXX_Size() int {
	return xxx_messageInfo_StartReindexResponse.Size(m)
}
func (m *StartReindexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReindexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartReindexResponse proto.InternalMessageInfo

func (m *StartReindexResponse) GetUpdate() string {
	if m != nil {
		return m.Update
	}
	return ""
}

func init() {
	proto.RegisterType((*IndexerInfo)(nil), "magma.orc8r.state.IndexerInfo")
	proto.RegisterType((*GetIndexersRequest)(nil), "magma.orc8r.state.GetIndexersRequest")
	proto.RegisterType((*GetIndexersResponse)(nil), "magma.orc8r.state.GetIndexersResponse")
	proto.RegisterMapType((map[string]*IndexerInfo)(nil), "magma.orc8r.state.GetIndexersResponse.IndexersByIdEntry")
	proto.RegisterType((*StartReindexRequest)(nil), "magma.orc8r.state.StartReindexRequest")
	proto.RegisterType((*StartReindexResponse)(nil), "magma.orc8r.state.StartReindexResponse")
}

func init() { proto.RegisterFile("indexer_manager.proto", fileDescriptor_1a75d319d3afccd2) }

var fileDescriptor_1a75d319d3afccd2 = []byte{
	// 361 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xc1, 0x6a, 0xf2, 0x40,
	0x14, 0x85, 0xff, 0x28, 0x8a, 0xde, 0x68, 0xfe, 0x3a, 0xda, 0x22, 0x42, 0x8b, 0x04, 0xac, 0xae,
	0x42, 0xb1, 0x5d, 0x48, 0x97, 0x42, 0x29, 0x29, 0x74, 0x93, 0x42, 0x17, 0x5d, 0x18, 0xc6, 0xe4,
	0x2a, 0xa1, 0x9a, 0xb1, 0x33, 0x13, 0x69, 0xa0, 0xaf, 0xd9, 0x3e, 0x4f, 0x69, 0x66, 0x2c, 0x11,
	0x03, 0x76, 0x95, 0xcc, 0xe1, 0xdc, 0x39, 0xe7, 0x7e, 0x0c, 0x9c, 0x46, 0x71, 0x88, 0xef, 0xc8,
	0xfd, 0x35, 0x8d, 0xe9, 0x12, 0xb9, 0xb3, 0xe1, 0x4c, 0x32, 0xd2, 0x5a, 0xd3, 0xe5, 0x9a, 0x3a,
	0x8c, 0x07, 0x13, 0xee, 0x08, 0x49, 0x25, 0xda, 0x1f, 0x60, 0xba, 0xca, 0xeb, 0xc6, 0x0b, 0x46,
	0xce, 0x01, 0x76, 0xa3, 0x51, 0xd8, 0x35, 0xfa, 0xc6, 0xa8, 0xee, 0xd5, 0xb5, 0xe2, 0x86, 0x64,
	0x00, 0x16, 0x0d, 0x64, 0x42, 0x57, 0xfe, 0x16, 0xb9, 0x88, 0x58, 0xdc, 0x2d, 0xf5, 0x8d, 0x51,
	0xd3, 0x6b, 0x2a, 0xf5, 0x59, 0x89, 0x64, 0x08, 0xff, 0x43, 0x14, 0x11, 0xc7, 0xf0, 0xd7, 0x57,
	0xce, 0x7c, 0x96, 0x96, 0xb5, 0xd1, 0xee, 0x00, 0xb9, 0x47, 0xa9, 0x0b, 0x08, 0x0f, 0xdf, 0x12,
	0x14, 0xd2, 0xfe, 0x32, 0xa0, 0xbd, 0x27, 0x8b, 0x0d, 0x8b, 0x05, 0x92, 0x19, 0x58, 0xba, 0x8a,
	0xf0, 0xe7, 0xa9, 0x2a, 0x58, 0x1e, 0x99, 0xe3, 0x89, 0x73, 0xb0, 0x97, 0x53, 0x30, 0xef, 0xec,
	0x84, 0x69, 0xea, 0x86, 0x77, 0xb1, 0xe4, 0xa9, 0xd7, 0x88, 0x72, 0x52, 0xcf, 0x87, 0xd6, 0x81,
	0x85, 0x9c, 0x40, 0xf9, 0x15, 0x53, 0x8d, 0xe2, 0xe7, 0x97, 0xdc, 0x40, 0x65, 0x4b, 0x57, 0x09,
	0x66, 0xbb, 0x9b, 0xe3, 0x8b, 0x82, 0xf4, 0x1c, 0x52, 0x4f, 0x99, 0x6f, 0x4b, 0x13, 0xc3, 0x7e,
	0x80, 0xf6, 0x93, 0xa4, 0x5c, 0x7a, 0x98, 0xe5, 0xea, 0x7d, 0x8f, 0x41, 0xef, 0x40, 0x65, 0xc1,
	0x78, 0xa0, 0xf2, 0x6a, 0x9e, 0x3a, 0xd8, 0x0e, 0x74, 0xf6, 0xef, 0xd2, 0x90, 0xce, 0xa0, 0x9a,
	0x6c, 0x42, 0x2a, 0x51, 0x5f, 0xa4, 0x4f, 0xe3, 0x4f, 0x03, 0x2c, 0x5d, 0xeb, 0x51, 0x3d, 0x0a,
	0x32, 0x03, 0x33, 0x87, 0x89, 0x0c, 0x8e, 0x61, 0xcc, 0xda, 0xf6, 0x2e, 0xff, 0x46, 0xdb, 0xfe,
	0x47, 0x02, 0x68, 0xe4, 0x2b, 0x92, 0xa2, 0xc9, 0x02, 0x1e, 0xbd, 0xe1, 0x51, 0xdf, 0x2e, 0xe2,
	0xca, 0x98, 0xd6, 0x5e, 0xaa, 0xd9, 0xe3, 0x16, 0x73, 0xf5, 0xbd, 0xfe, 0x0e, 0x00, 0x00, 0xff,
	0xff, 0x29, 0x5a, 0x6d, 0x8e, 0xfd, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// IndexerManagerClient is the client API for IndexerManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IndexerManagerClient interface {
	// GetIndexers returns indexer info for all tracked indexers.
	GetIndexers(ctx context.Context, in *GetIndexersRequest, opts ...grpc.CallOption) (*GetIndexersResponse, error)
	// StartReindex kicks off any required reindex jobs for some or all indexers.
	// Blocks till reindex job returns, streaming loggable updates.
	StartReindex(ctx context.Context, in *StartReindexRequest, opts ...grpc.CallOption) (IndexerManager_StartReindexClient, error)
}

type indexerManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewIndexerManagerClient(cc grpc.ClientConnInterface) IndexerManagerClient {
	return &indexerManagerClient{cc}
}

func (c *indexerManagerClient) GetIndexers(ctx context.Context, in *GetIndexersRequest, opts ...grpc.CallOption) (*GetIndexersResponse, error) {
	out := new(GetIndexersResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.state.IndexerManager/GetIndexers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexerManagerClient) StartReindex(ctx context.Context, in *StartReindexRequest, opts ...grpc.CallOption) (IndexerManager_StartReindexClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IndexerManager_serviceDesc.Streams[0], "/magma.orc8r.state.IndexerManager/StartReindex", opts...)
	if err != nil {
		return nil, err
	}
	x := &indexerManagerStartReindexClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IndexerManager_StartReindexClient interface {
	Recv() (*StartReindexResponse, error)
	grpc.ClientStream
}

type indexerManagerStartReindexClient struct {
	grpc.ClientStream
}

func (x *indexerManagerStartReindexClient) Recv() (*StartReindexResponse, error) {
	m := new(StartReindexResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IndexerManagerServer is the server API for IndexerManager service.
type IndexerManagerServer interface {
	// GetIndexers returns indexer info for all tracked indexers.
	GetIndexers(context.Context, *GetIndexersRequest) (*GetIndexersResponse, error)
	// StartReindex kicks off any required reindex jobs for some or all indexers.
	// Blocks till reindex job returns, streaming loggable updates.
	StartReindex(*StartReindexRequest, IndexerManager_StartReindexServer) error
}

// UnimplementedIndexerManagerServer can be embedded to have forward compatible implementations.
type UnimplementedIndexerManagerServer struct {
}

func (*UnimplementedIndexerManagerServer) GetIndexers(ctx context.Context, req *GetIndexersRequest) (*GetIndexersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexers not implemented")
}
func (*UnimplementedIndexerManagerServer) StartReindex(req *StartReindexRequest, srv IndexerManager_StartReindexServer) error {
	return status.Errorf(codes.Unimplemented, "method StartReindex not implemented")
}

func RegisterIndexerManagerServer(s *grpc.Server, srv IndexerManagerServer) {
	s.RegisterService(&_IndexerManager_serviceDesc, srv)
}

func _IndexerManager_GetIndexers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexerManagerServer).GetIndexers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.state.IndexerManager/GetIndexers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexerManagerServer).GetIndexers(ctx, req.(*GetIndexersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexerManager_StartReindex_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartReindexRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexerManagerServer).StartReindex(m, &indexerManagerStartReindexServer{stream})
}

type IndexerManager_StartReindexServer interface {
	Send(*StartReindexResponse) error
	grpc.ServerStream
}

type indexerManagerStartReindexServer struct {
	grpc.ServerStream
}

func (x *indexerManagerStartReindexServer) Send(m *StartReindexResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _IndexerManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.state.IndexerManager",
	HandlerType: (*IndexerManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIndexers",
			Handler:    _IndexerManager_GetIndexers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartReindex",
			Handler:       _IndexerManager_StartReindex_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "indexer_manager.proto",
}
