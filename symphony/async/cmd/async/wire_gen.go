// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"context"
	"fmt"

	"github.com/facebookincubator/symphony/async/handler"
	"github.com/facebookincubator/symphony/pkg/log"
	"github.com/facebookincubator/symphony/pkg/mysql"
	"github.com/facebookincubator/symphony/pkg/pubsub"
	"github.com/facebookincubator/symphony/pkg/server"
	"github.com/facebookincubator/symphony/pkg/server/xserver"
	"github.com/facebookincubator/symphony/pkg/telemetry"
	"github.com/facebookincubator/symphony/pkg/viewer"
	"github.com/gorilla/mux"
	"go.opencensus.io/stats/view"
	"go.uber.org/zap"
	"gocloud.dev/server/health"

	_ "github.com/go-sql-driver/mysql"

	_ "gocloud.dev/pubsub/mempubsub"

	_ "gocloud.dev/pubsub/natspubsub"
)

// Injectors from wire.go:

func NewApplication(ctx context.Context, flags *cliFlags) (*application, func(), error) {
	config := flags.MySQLConfig
	viewerConfig := flags.TenancyConfig
	logConfig := flags.LogConfig
	logger, cleanup, err := log.ProvideLogger(logConfig)
	if err != nil {
		return nil, nil, err
	}
	mySQLTenancy, err := newMySQLTenancy(config, viewerConfig, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	pubsubConfig := flags.EventConfig
	topicEmitter, cleanup2, err := pubsub.ProvideEmitter(ctx, pubsubConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	tenancy, err := newTenancy(mySQLTenancy, logger, topicEmitter)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	urlSubscriber := pubsub.ProvideSubscriber(pubsubConfig)
	telemetryConfig := &flags.TelemetryConfig
	handlerConfig := handler.Config{
		Tenancy:    tenancy,
		Logger:     logger,
		Subscriber: urlSubscriber,
		Telemetry:  telemetryConfig,
	}
	handlerServer := handler.NewServer(handlerConfig)
	router := mux.NewRouter()
	zapLogger := xserver.NewRequestLogger(logger)
	v := newHealthChecks(mySQLTenancy)
	v2 := provideViews()
	exporter, err := telemetry.ProvideViewExporter(telemetryConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	traceExporter, cleanup3, err := telemetry.ProvideTraceExporter(telemetryConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	profilingEnabler := _wireProfilingEnablerValue
	sampler := telemetry.ProvideTraceSampler(telemetryConfig)
	handlerFunc := xserver.NewRecoveryHandler(logger)
	defaultDriver := _wireDefaultDriverValue
	options := &server.Options{
		RequestLogger:         zapLogger,
		HealthChecks:          v,
		Views:                 v2,
		ViewExporter:          exporter,
		TraceExporter:         traceExporter,
		EnableProfiling:       profilingEnabler,
		DefaultSamplingPolicy: sampler,
		RecoveryHandler:       handlerFunc,
		Driver:                defaultDriver,
	}
	serverServer := server.New(router, options)
	logger2 := log.ProvideZapLogger(logger)
	mainApplication := newApplication(handlerServer, serverServer, logger2, flags)
	return mainApplication, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireProfilingEnablerValue = server.ProfilingEnabler(true)
	_wireDefaultDriverValue    = &server.DefaultDriver{}
)

// wire.go:

func newApplication(server2 *handler.Server, http *server.Server, logger *zap.Logger, flags *cliFlags) *application {
	var app application
	app.logger = logger
	app.server = server2
	app.http.Server = http
	app.http.addr = flags.HTTPAddr.String()
	return &app
}

func newTenancy(tenancy *viewer.MySQLTenancy, logger log.Logger, emitter pubsub.Emitter) (viewer.Tenancy, error) {
	return viewer.NewCacheTenancy(tenancy, nil), nil
}

func newHealthChecks(tenancy *viewer.MySQLTenancy) []health.Checker {
	return []health.Checker{tenancy}
}

func newMySQLTenancy(mySQLConfig mysql.Config, tenancyConfig viewer.Config, logger log.Logger) (*viewer.MySQLTenancy, error) {
	tenancy, err := viewer.NewMySQLTenancy(mySQLConfig.String(), tenancyConfig.TenantMaxConn)
	if err != nil {
		return nil, fmt.Errorf("creating mysql tenancy: %w", err)
	}
	tenancy.SetLogger(logger)
	mysql.SetLogger(logger)
	return tenancy, nil
}

func provideViews() []*view.View {
	views := xserver.DefaultViews()
	views = append(views, mysql.DefaultViews...)
	views = append(views, pubsub.DefaultViews...)
	return views
}
